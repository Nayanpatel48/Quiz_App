from datetime import datetime
from pydantic import BaseModel, EmailStr

# purpose of the code : while the previous SQLAlchemy code defined how your data is stored in the 
#                       database, this Pydantic code defines how your data should look when it 
#                       travels over the network.

# what BaseModel is doing?
# ans = Pydantic automatically checks that the data has the correct types and formats. 
# If it doesn't, it raises a ValidationError with a clear message, which prevents bad data from 
# ever reaching your database layer.

# BaseModel is a class that we inherit from pydantic.
class UserBase(BaseModel):
    username : str
    email : EmailStr 
    # EmailStr is a special type of datatype in pydantic that validates the email correctness.

# This defines the shape of the data you expect when creating a user.
# The user ID and other fields will be generated by the database.
class UserCreate(BaseModel):
    username : str
    email : str
    password : str

# this is the shape/format of the data you expect when you login a user
# the user id & other fields will be generated by database
class UserLogin(BaseModel):
    email : str
    password : str

# this is the shape/format of the data that you send back to the front end
class User(BaseModel):
    id : int
    username : str
    email : str
    created_at : datetime

    # This is most commonly used when working with a database. Your database library 
    # (like SQLAlchemy) gives you a db_user object. This setting lets Pydantic easily 
    # turn that db_user object into a Pydantic model for use in your API or application.
    
    # example : convert dictionary user =  {"name": "Alice", "age": 30} to
    # user_obj = User(name : str, age : int)
    # so user_obj.name = Alice, user_obj.age = 30.
    class Config:
        from_attributes = True

# this is the token related format/shape that you will send to the frontend
class Token(BaseModel):
    access_token : str
    token_type : str
    id : int

class HistorySchema(BaseModel):
    id : int
    test_name : str
    user_id : int
    score : int
    created_at : datetime

    class Config:
        from_attributes = True

# get current User schema
class GetCurrUser(BaseModel):
    id : int
    username : str
    email : str

# python questions schema
class PythonQuestionsSchema(BaseModel):
    id : int
    question : str
    option_a : str
    option_b : str
    option_c : str
    option_d : str
    answer : str

# js questions schema
class JsQuestionsSchema(BaseModel):
    id : int
    question : str
    option_a : str
    option_b : str
    option_c : str
    option_d : str
    answer : str

# dart questions schema
class DartQuestionsSchema(BaseModel):
    id : int
    question : str
    option_a : str
    option_b : str
    option_c : str
    option_d : str
    answer : str

# history save schema
class HistorySaveSchema(BaseModel): 
    test_name : str
    score : int